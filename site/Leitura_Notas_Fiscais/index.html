<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Nota Fiscal - Data_Platform DOC</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Nota Fiscal";
        var mkdocs_page_input_path = "Leitura_Notas_Fiscais.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Data_Platform DOC
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../API/">API</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Nota Fiscal</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#o-que-e">O que é?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ambiente">Ambiente</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#estrutra-do-algortimo">Estrutra do algortimo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#10-arquivo-leitura_nfpy">1.0 Arquivo "leitura_NF.py"</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11-entrada-e-saida-de-dados">1.1 Entrada e saída de dados</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12-contagem-de-arquivos">1.2 Contagem de arquivos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#13-criacao-do-loop">1.3 Criação do Loop</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#14-leitura-da-nota">1.4 Leitura da Nota</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#15-direcionamento-de-prefeitura">1.5 Direcionamento de prefeitura</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#16-pdf-com-imagem">1.6 PDF com imagem</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#17-prefeitura-nao-existente">1.7 Prefeitura não existente</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#18-tentativa-e-erro">1.8 Tentativa e Erro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#19-carregamento-de-leitura">1.9 Carregamento de leitura</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#110-tratamento-e-limpeza-do-dataframe">1.10 Tratamento e Limpeza do DataFrame</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#111-validacao-do-cnpj">1.11 Validação do CNPJ</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#112-coluna-de-novos-nomes">1.12 Coluna de Novos Nomes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#113-exportacao-do-resultado">1.13 Exportação do Resultado</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#114-contagem-do-tempo">1.14 Contagem do Tempo</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#20-arquivo-modulos_variaveispy">2.0 Arquivo "modulos_variaveis.py"</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21-funcao-para-nota-pdf">2.1 Função para nota PDF</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22-funcao-para-nota-pdf-de-baixa-qualidade">2.2 Função para nota PDF de baixa qualidade</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23-funcao-para-nota-pdf-de-imagem">2.3 Função para nota PDF de imagem</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24-funcao-para-leitura-da-nota">2.4 Função para leitura da nota</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25-funcao-alteracao-nome-de-coluna">2.5 Função alteração nome de coluna</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#26-funcao-limpa-acento">2.6 Função limpa acento</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#30-arquivo-modulos_prefeituraspy">3.0 Arquivo "modulos_prefeituras.py"</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#40-arquivo-modulos_renomeiapy">4.0 Arquivo "modulos_renomeia.py"</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#50-arquivo-modulos_empresaspy">5.0 Arquivo "modulos_empresas.py"</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#60-arquivo-modulos_ler_imagempy">6.0 Arquivo "modulos_ler_imagem.py"</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Data_Platform DOC</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Nota Fiscal</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="nota-facil">Nota Fácil</h1>
<h2 id="o-que-e">O que é?</h2>
<p>Trata-se de um algoritmo desenvolvido em Python, meticulosamente estruturado para processar arquivos de notas fiscais em formato PDF. O seu propósito é extrair as informações cruciais desses documentos, tais como número da nota, valor líquido, data de emissão, CNPJ e Razão Social tanto do prestador quanto do tomador de serviço. O resultado desse processo é então exportado e organizado em uma planilha do Excel, proporcionando um compilado abrangente e organizado das notas fiscais processadas.</p>
<p>&nbsp;</p>
<h2 id="ambiente">Ambiente</h2>
<p>Para garantir o funcionamento adequado do algoritmo, é recomendável utilizar o Python fornecido pelo Anaconda. Além disso, é necessário configurar a instalação de dois pacotes essenciais: Tesseract e Poopler para a leitura de imagens, conforme explicado detalhadamente no tópico 2.0. Essa configuração é crucial para garantir a eficiência e precisão do algoritmo, permitindo uma leitura eficaz das notas fiscais em formato PDF.</p>
<p>&nbsp;</p>
<h2 id="estrutra-do-algortimo">Estrutra do algortimo</h2>
<p>O algoritmo é composto por 6 arquivos em Python, de forma modularizada:</p>
<pre><code>leitura_NF.py

modulos_vairaveis.py

modulos_prefeituras.py

modulos_renomeia.py

modulos_empresas.py

modulos_ler_imagem.py
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="10-arquivo-leitura_nfpy">1.0 Arquivo "leitura_NF.py"</h2>
<p>Esse é o algoritmo que será executado para o processo de leitura rodar.</p>
<p>Primeiramente, preparo ambiente para a exportação dos dados das notas. Assim, crio um DataFrame para alocar todas as variáveis escolhidas das notas, e algumas colunas de metadados.</p>
<pre><code class="language-py">df = pd.DataFrame(columns=['Numero NF', 'Data Emissao', 'Valor Bruto', 'CNPJ Prestador', 'CNPJ Tomador', 'Razao Social Prestador','Razao Social Tomador', 'Prefeitura', 'Script','Caminho', 'Caminho Curto', 'Arquivo'])
</code></pre>
<div class="admonition example">
<ul>
<li><strong>Numero NF</strong>: número da nota fiscal</li>
<li><strong>Data Emissao</strong>: data (ou data e hora) em que a nota foi emitida</li>
<li><strong>Valor Bruto</strong>: valor bruto da nota fiscal (sem descontos)</li>
<li><strong>CNPJ Prestador</strong>: número do CNPJ do colaborador</li>
<li><strong>CNPJ Tomadorr</strong>: número do CNPJ da empresa GAV</li>
<li><strong>Razao Social Prestador</strong>: razão social do colaborador</li>
<li><strong>Razao Social Tomador</strong>: razão social da empresa GAV</li>
<li><strong>Prefeitura</strong>: local de prestação do serviço (ou prefeitura da nota emitida)</li>
<li><strong>Script</strong>: nome da função no código que a nota foi executada</li>
<li><strong>Caminho</strong>: caminho original de onde vem a nota</li>
<li><strong>Caminho Curto</strong>: últimas 3 pastas do caminho original</li>
<li><strong>Arquivo</strong>: nome do arquivo</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h4 id="11-entrada-e-saida-de-dados">1.1 Entrada e saída de dados</h4>
<p>Há duas forma de definir o input e output dos arquivos nesse código:</p>
<ul>
<li>Em formato de variável, importando as variáveis de caminho de entrada e saída de um arquivo .env. Assim, também crio uma lista com os diretórios de input.</li>
</ul>
<pre><code class="language-py">d1 = os.getenv('CAMINHO_NF')
d2 = os.getenv('CAMINHO_NF_TLK')
tabela_resposta = os.getenv('CAMINHO_RESULTADO')
lista_diretorios = [d1,d2]
</code></pre>
<div class="admonition example">
<ul>
<li><strong>os.getenv</strong>: recupera a variável do arquivo env</li>
<li><strong>tabela_resposta</strong>: contém o caminho de exportação do dataframe produzido no código</li>
<li><strong>lista_diretorios</strong>: lista que guarda os caminhos das notas</li>
</ul>
</div>
<ul>
<li>Definindo no próprio código diretamente</li>
</ul>
<pre><code class="language-py">d1 = r'C:\Users\usuario.nome\Pasta1\Pasta2\Notas_Comissoes\Notas-Salas'
d2 = r'C:\Users\usuario.nome\Pasta1\Pasta2\Notas_Comissoes\Notas-Promo-Tlmk'
tabela_resposta = r'C:\Users\usuario.nome\Pasta1\Pasta2\Notas_Comissoes\Resultado\Leitura.xlsx'
lista_diretorios = [d1,d2]
</code></pre>
<p>A diferença é que a primeira torna o código mais limpo e organizado.</p>
<p>&nbsp;</p>
<hr />
<h4 id="12-contagem-de-arquivos">1.2 Contagem de arquivos</h4>
<p>Após estabelecer os diretórios, navego por cada pasta e contabilizo a quantidade total de arquivos presentes. Isso é feito com o propósito de criar um monitoramento que apresenta a porcentagem de notas lidas em relação ao total previamente definido. Esse acompanhamento visa proporcionar uma visão clara do progresso na leitura das notas em relação à meta estabelecida.</p>
<pre><code class="language-py">qtd_arquivos = 0
for i in lista_diretorios:
    for diretorio_atual, subdiretorios, arquivos in os.walk(lista_diretorios[lista_diretorios.index(i)]):
            for arquivo in arquivos:
                qtd_arquivos += 1
</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="13-criacao-do-loop">1.3 Criação do Loop</h4>
<p>Estabeleço um loop que percorre cada diretório da lista de diretórios, adentrando em cada pasta de cada diretório e examinando, posteriormente, cada arquivo contido em cada pasta. Durante esse processo, verifica-se se o arquivo possui a extensão .pdf. Caso positivo, são definidas duas variáveis essenciais: o caminho completo do arquivo (caminho) e o caminho relativo em relação ao diretório principal (caminho curto). Por fim, o script imprime o caminho completo do arquivo em questão.</p>
<pre><code class="language-py">posicao = 0

for item in lista_diretorios:
    diretorio_inicial = lista_diretorios[posicao]
    posicao += 1
    for diretorio_atual, subdiretorios, arquivos in os.walk(diretorio_inicial):
        for arquivo in arquivos:
            try:
                if arquivo.lower().endswith('.pdf'): # Se é da extensão .pdf
                    caminho = diretorio_atual + '\\' + arquivo
                    caminho_curto = caminho.split('\\')[-4:-1]
                    caminho_curto = (caminho_curto[0] + '/' + caminho_curto[1] + '/' + caminho_curto[2]) 
                    print('CAMINHO DA NOTA =', caminho)

</code></pre>
<div class="admonition example">
<ul>
<li><strong>caminho</strong>: caminho de localização do arquivo</li>
<li><strong>caminho_curto</strong>: as três últimas pastas do caminho</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h5 id="14-leitura-da-nota">1.4 Leitura da Nota</h5>
<p>Após essa etapa, invoco a função responsável pela leitura da nota "le_contrato" (esclarecida no tópico 3.0), armazenando o resultado na variável "texto". Em seguida, o conteúdo passa por um processo de limpeza de espaçamentos e é armazenado na variável "texto_lista". Posteriormente, são removidos os valores vazios, transformando a variável em "texto_limpo". </p>
<p>Dessa forma, temos agora a variável fundamental para todo o código, que contém o texto totalmente tratado e pronto para ser utilizado nas próximas etapas.</p>
<pre><code class="language-py"># Executa função de ler o pdf
modulos_variaveis_v13.le_contrato(caminho)

# Armazena o texto
texto = modulos_variaveis_v13.output_string.getvalue()

# Tira os espaçamentos
texto_lista = texto.split('\n')
</code></pre>
<div class="admonition example">
<ul>
<li><strong>caminho</strong>: caminho de localização do arquivo</li>
<li><strong>caminho_curto</strong>: as três últimas pastas do caminho</li>
</ul>
</div>
<p><img alt="" src="../texto.jpg" /></p>
<p>&nbsp;</p>
<p><img alt="" src="../texto_limpo.jpg" /></p>
<p>&nbsp;</p>
<hr />
<h5 id="15-direcionamento-de-prefeitura">1.5 Direcionamento de prefeitura</h5>
<p>Após a extração do texto da nota, a variável "texto_limpo" é submetida a várias condicionais com o objetivo de determinar a qual prefeitura ela se relaciona. Uma vez identificada a prefeitura específica, o script executa o processo de captura das variáveis pertinentes utilizando o "modulo_variaveis", cujo funcionamento será detalhado posteriormente. </p>
<p>Esse conjunto de condicionais visa direcionar o fluxo do programa para a execução das etapas específicas associadas a cada prefeitura, garantindo uma abordagem personalizada e eficiente para cada caso.</p>
<pre><code class="language-py"># PREFEITURA DE NATAL
elif any('Prefeitura Municipal do Natal' in item for item in texto_limpo):
    modulos_variaveis.script_natal(texto_limpo, caminho, caminho_curto, arquivo, df)

# PREFEITURA DE MANAUS
elif any('PREFEITURA DE MANAUS' in item for item in texto_limpo):
    modulos_variaveis.script_manaus(texto_limpo, caminho, caminho_curto, arquivo, df)

# PREFEITURA DE RIO BRANCO
elif any('Prefeitura do Município de Rio Branco' in item for item in texto_limpo):
    modulos_variaveis.script_rio_branco(texto_limpo, caminho, caminho_curto, arquivo, df)
</code></pre>
<div class="admonition example">
<ul>
<li><strong>modulos_variaveis</strong>: módulo que contém o direcionamento de cada prefeitura específica</li>
<li><strong>modulos_variaveis.script_natal</strong>: função que direciona a execução da função específica da prefeitura natal, contida no "modulo_variaveis"</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h5 id="16-pdf-com-imagem">1.6 PDF com imagem</h5>
<p>Após passar por todas as condicionais de processamento dos textos relacionadas às prefeituras, o código realiza uma verificação final. Ele avalia se a variável "texto_limpo" contém os caracteres '\x0c' ou '\n0'. Se essa condição for satisfeita, indica que o texto é proveniente de uma nota em PDF não selecionável, como uma imagem de um print.</p>
<pre><code class="language-py">elif texto == '\x0c' \
or '\x0c' in texto \
or '\n0' in texto :
</code></pre>
<p>Nesse cenário, ao atender a essa condição, o código executa um processo para extrair os dados dessa imagem (explicado no tópico "modulo_ler_imagem"), e aloca o resultado na variável "texto_imagem".
Assim, "texto imagem" que recebeu uma lista com o resultado da leitura da nota em imagem, passa por um processo de limpeza, eliminando caracteres vazios e linhas nulas.</p>
<pre><code class="language-py">script = 'imagem'

# Executa scritp de leitra de imagem
texto_imagem = modulos_ler_imagem.get_text_from_any_pdf(caminho)
texto_imagem = texto_imagem.split('\n')
texto_imagem = [item.strip() for item in texto_imagem if item.strip() != '']
</code></pre>
<div class="admonition example">
<ul>
<li><strong>caminho</strong>: caminho de localização do arquivo</li>
</ul>
</div>
<p>A partir deste ponto, o código continua a percorrer as condições subsequentes, verificando se o conteúdo se encaixa em alguma prefeitura específica.</p>
<pre><code class="language-py"># PREFEITURA DE UBERABA IMAGEM
elif any('PREFEITURA MUNICIPAL DE UBERABA' in item for item in texto_imagem):
    modulos_variaveis.script_uberaba_imagem(texto_imagem, caminho, caminho_curto, arquivo, df)

# PREFEITURA DE BELÉM IMAGEM
elif any('PREFEITURA MUNICIPAL DE BELEM' in item for item in texto_imagem):
    modulos_variaveis.script_belem_imagem(texto_imagem, caminho, caminho_curto, arquivo, df)

# PREFEITURA DE ANANINDEUA IMAGEM
elif any('PREFEITURA MUNICIPAL DE ANANINDEUA' in item for item in texto_imagem):
    modulos_variaveis.script_ananindeua_imagem(texto_imagem, caminho, caminho_curto, arquivo, df)
</code></pre>
<div class="admonition example">
<ul>
<li><strong>modulos_variaveis</strong>: módulo que contém o direcionamento de cada prefeitura específica</li>
<li><strong>modulos_variaveis.script_uberaba_imagem</strong>: função que direciona a execução da função específica da prefeitura de uberaba (em formato de imagem), contida no "modulo_variaveis"</li>
</ul>
</div>
<div class="admonition tip">
<p class="admonition-title">Nota</p>
<p>Por que algumas notas são em formato de PDF normal e outras em formato PDF com imagem?
A variação no formato das notas em PDF ocorre devido ao processo descentralizado de geração, onde cada colaborador é responsável pela emissão de suas próprias notas. Durante esse processo, algumas notas são geradas de maneira não padrão, resultando em PDFs com texto não selecionável. </p>
</div>
<p>&nbsp;</p>
<hr />
<h5 id="17-prefeitura-nao-existente">1.7 Prefeitura não existente</h5>
<p>Após percorrer todas as condições relacionadas aos casos de texto e imagem, e não encontrar uma correspondência em nenhuma delas, a variável é redirecionada para a cláusula "else". Nesse ponto, o código tenta, pelo menos, extrair o nome da prefeitura associada ao novo caso.Se bem-sucedido, o nome da prefeitura é extraído, e as outras variáveis são configuradas como brancas. Em seguida, todas as variáveis são adicionadas a uma lista, que é inserida no dataframe.</p>
<p>No caso de não ser possível extrair o nome da prefeitura, a variável fica com o valor "nao_achado", e, juntamente com as outras variáveis em branco, uma lista é criada e inserida como uma nova linha no dataframe. Nesse caso, a variável script, que contém qual script da variável modulo_variaveis foi ativado, fica com o valor "sem_codigo". </p>
<p>Essa abordagem permite lidar de maneira flexível com situações não previamente mapeadas, buscando ao menos identificar o nome da prefeitura mesmo quando a estrutura do documento não segue os padrões conhecidos.</p>
<pre><code class="language-py">else:
for indice, item in enumerate(texto_imagem):
    if 'prefeitura' in item.lower() or 'município' in item.lower():
        prefeitura = texto_imagem[indice]
        break
    else:
        prefeitura = 'nao_achado'

num_nf = ''
data_emissao = ''
vlr_liquido = '' 
cnpj_prestador = ''
cnpj_tomador = ''
razao_prestador = ''
razao_tomador = ''
script = 'sem_codigo'

lista_variaveis = [num_nf,data_emissao, vlr_liquido, 
                cnpj_prestador, cnpj_tomador, 
                razao_prestador, razao_tomador, 
                prefeitura, script, caminho, caminho_curto, arquivo]

# Inserção da lista no DataFrame
df.loc[len(df)] = lista_variaveis
</code></pre>
<div class="admonition example">
<ul>
<li><strong>df</strong>: datafrane que está sendo construído durante o código</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h5 id="18-tentativa-e-erro">1.8 Tentativa e Erro</h5>
<p>Todo esse código que exerce sobre esse arquivo selecionado no loop de pastas, passa por um processo de tentativa e erro, utilizando o "try except". Dessa forma, mesmo que ocorra algum erro durante a execução, o algoritmo não irá travar. Nesse sentido, ele simplesmente irá entender aquela nota como erro, preencher a lista_variaveis com a palavra "erro" nas variáveis, e inseri-la nno dataframe.</p>
<pre><code class="language-py">try:
    if arquivo.lower().endswith('.pdf'): # Se é da extensão .pdf
        caminho = diretorio_atual + '\\' + arquivo
        caminho_curto = caminho.split('\\')[-4:-1]
        caminho_curto = (caminho_curto[0] + '/' + caminho_curto[1] + '/' + caminho_curto[2]) 
        print('CAMINHO DA NOTA =', caminho)

        ...

except Exception as e:
    lista_variaveis = ['erro', 'erro', 'erro', 'erro', 'erro', 'erro', 'erro', 'erro', e, caminho, caminho_curto, arquivo]
    df.loc[len(df)] = lista_variaveis

</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="19-carregamento-de-leitura">1.9 Carregamento de leitura</h4>
<p>Para haver um acompanhamento da leitura, o algortimo expoe no terminal algumas informações:</p>
<ul>
<li>O nome do arquivo (escrito no no início do loop);</li>
<li>Quantidade de notas lidas;</li>
<li>Quantidade e porcentagem de notas imperfeitas (qualquer uma que não tiver a palavra "script" dentro da variável "script", ou seja, que não tem nenhuma unção apropriada para aquela prefeitura);</li>
<li>Visualização de uma barra de progresso (baseada na quantidade de notas lidas pelo total).</li>
</ul>
<pre><code class="language-py"># Calcula notas com algum tipo de erro ou não leitura
Soma_Notas_Erro = np.sum(np.logical_not(df['Script'].str.contains('script')))
Porcentagem = round((Soma_Notas_Erro / qtd_arquivos) * 100,2)

# Mostra barra de processamento
print('Quantidade NOTAS LIDAS =', len(df),'/', qtd_arquivos)
print('Quantidade NOTAS IMPERFEITAS =', Soma_Notas_Erro, '==', Porcentagem, '%')
lista_df = list(range(1,len(df)+1))

for i in tqdm(list(range(1,len(df)+1)), total=qtd_arquivos,  unit=&quot;item&quot;, bar_format=&quot;{desc}: {percentage:.2f}% {bar}&quot;,desc=&quot;Processando&quot;):
    pass
</code></pre>
<div class="admonition example">
<ul>
<li><strong>qtd_arquivos</strong>: quantidade total de arquivos, calculada na sessão "1.2 Contagem de arquivos"</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h4 id="110-tratamento-e-limpeza-do-dataframe">1.10 Tratamento e Limpeza do DataFrame</h4>
<p>Após a criação do DataFrame, realiza-se ajustes para aprimorar a qualidade dos dados. Especificamente:</p>
<ul>
<li>Coluna CNPJ:<ul>
<li>Remoção de caracteres não numéricos, mantendo apenas os dígitos.</li>
<li>Correção de um CNPJ específico para evitar interpretação incorreta</li>
</ul>
</li>
<li>Coluna Valor:<ul>
<li>Eliminação de caracteres não numéricos, garantindo apenas valores numéricos.</li>
</ul>
</li>
<li>Coluna Data:<ul>
<li>Substituição de '-' por '/', uniformizando o formato.</li>
<li>Padronização de todas as datas para o formato dd/mm/aaaa.</li>
</ul>
</li>
</ul>
<pre><code class="language-py">df['CNPJ Prestador'] = df['CNPJ Prestador'].str.replace(r'\D', '', regex=True)
df['CNPJ Prestador'] = df['CNPJ Prestador'].str.strip()

df['CNPJ Tomador'] = df['CNPJ Tomador'].str.replace(r'\D', '', regex=True)
df['CNPJ Tomador'] = df['CNPJ Tomador'].str.strip()

# Substitui a leitura errada do cnpj de GAV GRAMADO TRES
df['CNPJ Tomador'] = df['CNPJ Tomador'].str.replace('90094155000102', '50094155000102')

df['Valor Liquido'] = df['Valor Liquido'].str.replace(r'[a-zA-Z$]', '', regex=True)

df['Data Emissao'] = df['Data Emissao'].str.replace(r'-', '/', regex=True)
df['Data Emissao'] = df['Data Emissao'].str.extract(r'(\d{2}/\d{2}/\d{4})', expand = False)
</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="111-validacao-do-cnpj">1.11 Validação do CNPJ</h4>
<p>Para validar a consistência dos CNPJs do Tomador nas notas fiscais em relação às empresas registradas no banco de dados, realizamos a extração da tabela de empresas do DW, situada no módulo empresas. Utilizando Python, efetuamos a limpeza e tratamento necessários na tabela de empresas para garantir a integridade dos dados. Em seguida, comparamos os CNPJs do Tomador nas notas fiscais com os CNPJs da tabela de empresas. </p>
<p>Quando há correspondência, incorporamos ao DataFrame das notas fiscais duas novas colunas: 'Codigo Tomador' com o código da empresa correspondente, e 'Empresa Tomador' com a razão social correspondente. Este processo tem como objetivo assegurar a conformidade dos CNPJs do Tomador com as empresas registradas, proporcionando uma análise consistente dos dados.</p>
<pre><code class="language-py"># Conexão com tabela empresas do banco
df_empresas = modulos_empresas.df_empresas
df_empresas = df_empresas.drop_duplicates(subset='cnpj', keep='first')
df_empresas['cod_empresa'] = df_empresas['cod_empresa'].astype(int)
df_empresas['cod_empresa'] = round(df_empresas['cod_empresa'])
df_empresas['cod_empresa'] = df_empresas['cod_empresa'].astype(str)

# Especifica o codigo da empresa
df['Codigo Tomador'] = np.where(
    df['CNPJ Tomador'].isin(df_empresas['cnpj']),
    df['CNPJ Tomador'].map(df_empresas.set_index('cnpj')['cod_empresa']),
    '-'
)

# Especifica a razao social da empresa
df['Empresa Tomador'] = np.where(
    df['CNPJ Tomador'].isin(df_empresas['cnpj']),
    df['CNPJ Tomador'].map(df_empresas.set_index('cnpj')['empresa']),
    '-'
)
</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="112-coluna-de-novos-nomes">1.12 Coluna de Novos Nomes</h4>
<p>Com o intuito de padronizar os nomes dos arquivos de acordo com o conteúdo das notas fiscais, introduzimos uma coluna com um formato padrão: "Razão social do prestador + código do tomador + valor do serviço da nota". A criação dessa coluna é realizada invocando a função coluna_altera_nome do módulo variáveis. </p>
<p>Posteriormente, efetuamos uma limpeza na coluna, substituindo caracteres específicos e removendo acentos utilizando a função unidecode. Essa estratégia visa estabelecer uma identificação uniforme e descritiva para cada nota fiscal, facilitando a organização e referência dos arquivos</p>
<pre><code class="language-py"># Cria a coluna com o nome do arquivo alterado
df['Arquivo_Nome_Alterado'] = df.apply(modulos_variaveis.coluna_altera_nome, axis=1)
df['Arquivo_Nome_Alterado'] = df['Arquivo_Nome_Alterado'].apply(modulos_variaveis_v13.limpa_acento)
df['Arquivo_Nome_Alterado'] = df['Arquivo_Nome_Alterado'].str.replace(&quot;'&quot;, '')
df['Arquivo_Nome_Alterado'] = df['Arquivo_Nome_Alterado'].str.replace(&quot;@&quot;, '')
df['Arquivo_Nome_Alterado'] = df['Arquivo_Nome_Alterado'].astype(str)
df['Arquivo_Nome_Alterado'] = df['Arquivo_Nome_Alterado'].apply(unidecode)
</code></pre>
<p>Depois, é chamada a função que renomeia o próprio arquivo, contida no modulo renomear.</p>
<pre><code class="language-py"># Renomeia os arquivos
modulos_renomear.renomeia(df)
</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="113-exportacao-do-resultado">1.13 Exportação do Resultado</h4>
<p>Durante o tratamento do dataframe já feito, utiliza-se alguns comandos de exportação dessa tabela para o Excel, com o intuito de garantir que, mesmo que o código dê algum erro no final, seja possível exportar a tabela, mesmo sem tratamento</p>
<pre><code class="language-py">df.to_excel(r'C:\Users\usuario.nome\Pasta1\Pasta2\Resultado.xlsx', index=False)
</code></pre>
<p>Mas no fim do código, exporta-se o dataframe pelo caminho de retorno indicado no arquivo .env</p>
<pre><code class="language-py">df.to_excel(tabela_resposta, index=False)
</code></pre>
<p>&nbsp;</p>
<hr />
<h4 id="114-contagem-do-tempo">1.14 Contagem do Tempo</h4>
<p>Por fim, é exposto no terminal o tempo total da leitura das notas.</p>
<pre><code class="language-py"># Conta o tempo de execução
tempo_final = time.time()
tempo_total = (tempo_final - tempo_inicio)/60
print('exportado para excel')
print('Tempo total', tempo_total, 'minutos')
</code></pre>
<p><img alt="alt text" src="../texto.jpg" /></p>
<p>&nbsp;</p>
<hr />
<h2 id="20-arquivo-modulos_variaveispy">2.0 Arquivo "modulos_variaveis.py"</h2>
<p>O objetivo principal deste módulo é orientar a execução para funções específicas dentro do módulo_prefeitura e também armazenar algumas funções de uso geral que serão utilizadas no módulo principal.</p>
<h4 id="21-funcao-para-nota-pdf">2.1 Função para nota PDF</h4>
<p>Um exemplo de função de direcionamento para o módulo_prefeitura é o seguinte:</p>
<ol>
<li>Inicialmente, é determinada uma variável chamada "script" que indica o nome do script atualmente em execução.</li>
<li>Em seguida, é invocada a função "pref_natal" do módulo_prefeitura. Esta função é responsável por extrair as variáveis necessárias de uma nota, seguindo o contexto do script atual.</li>
<li>As variáveis extraídas são então reunidas em uma lista.</li>
<li>Posteriormente, essa lista de variáveis é inserida no dataframe que está sendo construído, possibilitando a organização e manipulação dos dados.</li>
</ol>
<p>Este procedimento fornece uma clareza sobre o fluxo de execução do script, garantindo que as variáveis relevantes sejam corretamente extraídas e incorporadas ao dataframe em construção.</p>
<pre><code class="language-py">def script_natal(texto_limpo, caminho, caminho_curto, arquivo, df):

    script = 'natal_script'

    modulo_prefeitura.pref_natal(texto_limpo) 

    lista_variaveis = [modulos_prefeitura.num_nf, modulos_prefeitura.data_emissao, modulos_prefeitura.vlr_liquido, 
                    modulos_prefeitura.cnpj_prestador, modulos_prefeitura.cnpj_tomador, 
                    modulos_prefeitura.razao_prestador, modulos_prefeitura.razao_tomador, 
                    modulos_prefeitura.prefeitura, script, caminho, caminho_curto, arquivo]

    df.loc[len(df)] = lista_variaveis
</code></pre>
<div class="admonition example">
<ul>
<li><strong>texto_limpo</strong>: texto extraído da leitura do arquivo pdf</li>
<li><strong>caminho</strong>: caminho de localização do arquivo</li>
<li><strong>caminho_curto</strong>: as três últimas pastas do caminho</li>
<li><strong>arquivo</strong>: : nome do arquivo</li>
<li><strong>df</strong>: datafrane que está sendo construído durante o código</li>
<li><strong>lista_variaveis</strong>: lista contendo todas as variáveis extraídas da nota</li>
</ul>
</div>
<p>Essa função de "script_prefeituraX" se repete dezenas de vezes, pois é criado a cada prefeitura existente dentro das pastas de notas. </p>
<hr />
<h4 id="22-funcao-para-nota-pdf-de-baixa-qualidade">2.2 Função para nota PDF de baixa qualidade</h4>
<p>Existe uma variante adicional da função "script", na qual a nota inicial é apresentada como um texto convencional. No entanto, dentro dessa função, é realizada uma leitura de imagem da nota para otimizar a qualidade do texto extraído. Isso se torna especialmente relevante em casos nos quais algumas prefeituras disponibilizam notas em formato PDF comum, resultando em uma extração de texto de baixa qualidade. Ao empregar a leitura de imagem, busca-se aprimorar a precisão e clareza do texto obtido.</p>
<pre><code class="language-py">def script_rio_largo(caminho, caminho_curto, arquivo, df):

    script = 'rio_largo_script'

    texto_imagem = modulos_ler_imagem_v1.get_text_from_any_pdf(caminho)
    texto_imagem = texto_imagem.split('\n')
    texto_imagem = [item.strip() for item in texto_imagem if item.strip() != '']

    modulos_prefeitura.pref_rio_largo(texto_imagem)

    lista_variaveis = [modulos_prefeitura.num_nf, modulos_prefeitura.data_emissao, modulos_prefeitura.vlr_liquido, 
                    modulos_prefeitura.cnpj_prestador, modulos_prefeitura.cnpj_tomador, 
                    modulos_prefeitura.razao_prestador, modulos_prefeitura.razao_tomador, 
                    modulos_prefeitura.prefeitura, script, caminho, caminho_curto, arquivo]

    df.loc[len(df)] = lista_variaveis
</code></pre>
<div class="admonition example">
<ul>
<li><strong>texto_imagem</strong>: texto extraído da leitura do arquivo pdf com imagem</li>
</ul>
</div>
<hr />
<h4 id="23-funcao-para-nota-pdf-de-imagem">2.3 Função para nota PDF de imagem</h4>
<p>Existe também uma tereceira variante adicional da função "script", usada nas notas pdf com imagem. Com isso, em vez da entrada de texto_limpo, terá de texto_imagem.</p>
<p>Neste contexto, dado que a função principal do algoritmo já incorpora a capacidade de realizar a leitura de imagens ao identificar que um PDF é do tipo imagem, não é necessário explicitar a função de leitura de imagem dentro da função "script". Em vez disso, basta utilizar o nome da variável que contém a imagem como entrada para garantir a efetiva leitura e processamento.</p>
<pre><code class="language-py">def script_recife(texto_imagem, caminho, caminho_curto, arquivo, df):

    script = 'recife_script'

    modulos_prefeitura.pref_recife(texto_imagem)

    lista_variaveis = [modulos_prefeitura.num_nf, modulos_prefeitura.data_emissao, modulos_prefeitura.vlr_liquido, 
                    modulos_prefeitura.cnpj_prestador, modulos_prefeitura.cnpj_tomador, 
                    modulos_prefeitura.razao_prestador, modulos_prefeitura.razao_tomador, modulos_prefeitura.prefeitura,
                    script, caminho, caminho_curto, arquivo]

    df.loc[len(df)] = lista_variaveis

</code></pre>
<div class="admonition example">
<ul>
<li><strong>texto_imagem</strong>: texto extraído da leitura do arquivo pdf com imagem</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h4 id="24-funcao-para-leitura-da-nota">2.4 Função para leitura da nota</h4>
<p>A função le_contrato tem como objetivo ler um contrato em formato PDF, utilizando a biblioteca PDFminer Ela realiza a extração de texto de cada página do PDF e armazena o resultado em uma variável global chamada output_string. Essa função é útil quando se deseja processar o conteúdo textual de contratos presentes em documentos PDF.</p>
<pre><code class="language-py">def le_contrato(caminho):
    '''Lê contrato em pdf'''
    # Variável global para armazenar o texto extraído
    global output_string
    output_string = StringIO()

    # Abre o arquivo PDF no modo de leitura binária
    with open(caminho, 'rb') as in_file:
        # Cria um objeto PDFParser para analisar o conteúdo do arquivo PDF
        parser = PDFParser(in_file)
        # Gera um objeto PDFDocument com base no parser
        doc = PDFDocument(parser)

    # Criação de objetos para gerenciar recursos e converter texto
    rsrcmgr = PDFResourceManager()
    # TextConverter converte o conteúdo do PDF em texto
    device = TextConverter(rsrcmgr, output_string, laparams=LAParams())

    # Cria um objeto PDFPageInterpreter para interpretar as páginas do PDF
    interpreter = PDFPageInterpreter(rsrcmgr, device)

    # Itera sobre cada página do documento PDF
    for page in PDFPage.create_pages(doc):
        # Processa o conteúdo de cada página, convertendo-o em texto e armazenando em output_string
        interpreter.process_page(page)
</code></pre>
<div class="admonition example">
<ul>
<li><strong>caminho</strong>: caminho de localização do arquivo</li>
</ul>
</div>
<p>Dessa forma, é retornada a variável output_string, que no arquivo leitura_NF.py, irá ser chamada.</p>
<p>&nbsp;</p>
<hr />
<h4 id="25-funcao-alteracao-nome-de-coluna">2.5 Função alteração nome de coluna</h4>
<p>Uma utilidade do algoritmo é criar uma coluna no dataframe com o novo nome de alteração do arquivo, um nome padronizado com 'razao social do prestador_codigo da empresa_valor da nota'.</p>
<p>Esta função, <code>coluna_altera_nome</code>, tem como objetivo criar uma nova coluna em um DataFrame, contendo nomes de arquivos padronizados. O novo nome é formado pela combinação de três colunas específicas do DataFrame: "Razao Social Prestador", "Codigo Tomador", e "Valor Liquido". </p>
<p>No entanto, o novo nome só é gerado se os valores dessas colunas atenderem a critérios específicos, incluindo a verificação de certos valores indesejados e limites de caracteres. Se os critérios são satisfeitos, a função retorna o novo nome; caso contrário, retorna o valor original da coluna "Arquivo". Em situações excepcionais, a função pode retornar "Excedeu_Caracter" se o novo nome ultrapassar o limite de caracteres ou "Nao" em caso de exceção.</p>
<pre><code class="language-py">def coluna_altera_nome(row):
    # Obtém os valores das colunas relevantes do DataFrame
    prestador = row['Razao Social Prestador']
    tomador = row['Codigo Tomador']
    valor = row['Valor Liquido']
    arquivo = row['Arquivo']

    try:
        # Verifica se os valores atendem aos critérios para a criação de um novo nome
        if (prestador is not None and prestador.strip()) and prestador not in ['erro'] and prestador != 'nao_achado' and \
            tomador != '-' and \
            (valor is not None and valor.strip()) and valor not in ['erro'] and valor != 'nao_achado' and valor != '_':

            # Cria um novo nome conforme o padrão estabelecido
            novo_nome = prestador + '__EMP' + tomador + '__' + str(valor) + '.pdf'

            # Verifica se o novo nome não excede o limite de 256 caracteres
            if len(novo_nome) &lt;= 256:
                return novo_nome
            else:
                # Retorna um indicativo caso o novo nome exceda o limite de caracteres
                return 'Excedeu_Caracter'
        else:
            # Se os critérios não forem atendidos, retorna o valor original da coluna 'Arquivo'
            return arquivo
    except:
        # Retorna 'Nao' em caso de exceção
        return 'Nao'

</code></pre>
<div class="admonition example">
<ul>
<li><strong>row</strong>: linha do DataFrame</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h4 id="26-funcao-limpa-acento">2.6 Função limpa acento</h4>
<p>Esta função, <code>limpa_acento</code>, tem como objetivo remover caracteres epeciais e acentos.</p>
<pre><code class="language-py">def limpa_acento(texto):
    try:
        return unidecode(str(texto))
    except:
        return texto
</code></pre>
<div class="admonition example">
<ul>
<li><strong>texto</strong>: entrada do texto que se deseja limpar</li>
</ul>
</div>
<p>&nbsp;</p>
<hr />
<h2 id="30-arquivo-modulos_prefeituraspy">3.0 Arquivo "modulos_prefeituras.py"</h2>
<p>O propósito deste arquivo é criar um script dedicado para cada prefeitura, com o objetivo de extrair informações cruciais de notas fiscais. As variáveis de interesse incluem o número da nota, a data de emissão, o valor bruto, a razão social, o CNPJ dos prestadores e tomadores de serviço, além do nome da prefeitura (local de prestação do serviço).</p>
<p>Cada script específico para uma prefeitura é definido como uma função, onde um loop <code>for</code> é empregado para percorrer todas as linhas do texto da nota. Dentro desse loop, há a busca por palavras-chave específicas. Ao encontrar uma correspondência, o script captura o valor associado e armazena-o em uma variável. Isso permite a extração eficiente de cada variável relevante do texto da nota fiscal.</p>
<p>Em alguns casos, ao invés de buscar por uma palavra-chave específica como "data de emissão", o script adota a abordagem de percorrer todo o texto em busca de padrões, como "dd/mm/aaaa". Essa estratégia é aplicada de maneira semelhante para a identificação de CNPJ.</p>
<p>É importante ressaltar que tanto notas no formato de imagem quanto em PDF possuem funções específicas para cada prefeitura, e estas fornecem a variável que armazena o texto da nota como entrada para a função.</p>
<p>As variáveis extraídas, contendo as informações relevantes, são consolidadas em uma lista. Essa lista é criada no módulo_variaveis, conforme detalhado no tópico 2.0, e posteriormente é utilizada para alimentar um dataframe. Essa abordagem possibilita a organização e estruturação eficiente das informações extraídas das notas fiscais.</p>
<pre><code class="language-py">def pref_goncalves(texto_imagem):
    global prefeitura, num_nf, data_emissao, vlr_liquido, razao_prestador, razao_tomador, cpf, cnpj_prestador, cnpj_tomador

    # PREFEITURA
    prefeitura = 'PREFEITURA MUNICIPAL DE GOLCALVEZ DIAS'

    # extrair NUMERO NOTA FISCAL
    for indice, item in enumerate(texto_imagem):
        if 'numero da nota' in item.lower():
            num_nf = texto_imagem[indice+1]
            break
        else:
            num_nf = 'nao_achado'


    # extrair DATA EMISSAO 
    padrao = r'\d{2}/\d{2}/\d{4}'
    posicoes = []
    for elemento in texto_imagem:
        match = re.search(padrao, elemento)
        if match:
            posicoes.append(match.group())
        else:
            data_emissao = 'nao_achado'

    data_emissao = posicoes[0]


    # extrair VALOR LÍQUIDO
    for indice, item in enumerate(texto_imagem):
        if 'liquido' in item.lower():
            vlr_liquido = texto_imagem[indice+1]
            break
        else:
            vlr_liquido = 'nao_achado'

    if ' ' in vlr_liquido:
        vlr_liquido = vlr_liquido.split(' ')[-1].strip()


    # extrair RAZÃO
    posicoes = []
    for indice, item in enumerate(texto_imagem):
        if 'social' in item.lower():
            posicoes.append(indice)
        else:
            razao_prestador = 'nao_achado'
            razao_tomador = 'nao_achado'

    razao_prestador = texto_imagem[posicoes[0]+1]
    if ':' in razao_prestador:
        razao_prestador = razao_prestador.split(':')[-1].strip()

    razao_tomador = texto_imagem[posicoes[1]+1]
    if ':' in razao_tomador:
        razao_tomador = razao_tomador.split(':')[-1].strip()


    # extrair CPF
    posicoes = []
    for indice, item in enumerate(texto_imagem):
        if 'cpf' in item.lower():
            posicoes.append(indice)
        else:
            cnpj_prestador = 'nao_achado'
            cnpj_tomador = 'nao_achado'

    padrao = r'\d{2}\.\d{3}\.\d{3}/\d{4}-\d{2}'

    cnpj_prestador = texto_imagem[posicoes[0]+1]
    if not re.findall(padrao, cnpj_prestador):
        cnpj_prestador = cnpj_prestador
    else:
        cnpj_prestador = re.findall(padrao, cnpj_prestador)[0]

    cnpj_tomador = texto_imagem[posicoes[1]+1]
    if not re.findall(padrao, cnpj_tomador):
        cnpj_tomador = cnpj_tomador
    else:
        cnpj_tomador = re.findall(padrao, cnpj_tomador)[0]
</code></pre>
<p>&nbsp;</p>
<div class="admonition tip">
<p class="admonition-title">Nota</p>
<p><em>Por que não se usa apenas uma função prefeitura para extrair as variáveis de todas as notas?</em></p>
<p>A escolha de utilizar funções específicas para cada prefeitura, em vez de uma função única para todas as notas, se deve à natureza única do formato de texto extraído de cada prefeitura específica. Cada prefeitura pode adotar um formato único de nota fiscal, resultando em diferenças nos nomes das palavras-chave relevantes e nas posições dessas palavras-chave no texto. Por isso é uma função para a prefeitura de Natal, outra para a prefeitura de Gonçalves Dias, outra para Goiânia e assim por diante.</p>
<p>Por exemplo, o termo que representa o "Valor Bruto" em uma nota da prefeitura X pode ser diferente de outra nota da prefeitura Y, podendo ser "Valor Total" ou "Valor dos Serviços". Além disso, as posições dessas palavras-chave e dos valores associados podem variar.</p>
<p>Mesmo para notas emitidas pela mesma prefeitura, as variações na formatação dos PDFs e suas dimensões podem influenciar a qualidade do texto extraído, resultando em diferenças nas posições das palavras-chave. Por isso, usando o exemplo da prefeitura da cidade de Olimpia, há duas funções diferentes ensse módulo: pref_olimpia e pref_olimpia2.</p>
<p>Assim, a abordagem de ter funções específicas para cada prefeitura permite lidar de maneira mais flexível com essas variações, garantindo a precisão na extração das variáveis, mesmo em cenários onde os formatos das notas podem ser distintos.</p>
</div>
<p>&nbsp;</p>
<p>Um ponto extremamente positivo é que, atualmente, foi estabelecido um padrão para notas fiscais do tipo MEI, abrangendo cerca de 50% das notas que seguem esse formato padronizado. Nesse contexto, destaca-se a função pref_danfse, especialmente desenvolvida para esse tipo específico de nota. Essa função demonstra uma leitura de alta qualidade e uma extração de variáveis bastante precisa.</p>
<p>No módulo_prefeituras, foram implementadas quatro funções dedicadas ao processamento de notas fiscais do tipo MEI. A necessidade de quatro funções distintas surge de possíveis variações nas dimensões do papel da nota durante a emissão, o que demanda um reconhecimento específico para cada cenário.</p>
<p>Essa abordagem permite uma extração eficiente e acurada de informações, contribuindo para o sucesso na interpretação e manipulação das notas fiscais MEI, mesmo diante de possíveis variações nas suas características físicas.</p>
<p>&nbsp;</p>
<hr />
<p><img src="texto.jpg" width="800" height="400"></p>
<h2 id="40-arquivo-modulos_renomeiapy">4.0 Arquivo "modulos_renomeia.py"</h2>
<p>Este script foi desenvolvido com o propósito de renomear cada arquivo de nota fiscal de acordo com os nomes indicados na coluna 'Arquivo_Nome_Alterado', mencionada no tópico 1.12.</p>
<p>A função <code>renomeia</code> (chamada no arquivo leitura_nf.py) emprega um loop para percorrer as linhas de um DataFrame (df) contendo informações sobre arquivos. Em cada iteração, o código obtém o caminho e o nome do arquivo antigo, e então cria um novo caminho com base no nome alterado e um apelido correspondente. O objetivo principal é renomear os arquivos e atualizar as informações associadas no DataFrame.</p>
<p>Ao tentar efetuar a renomeação, o código utiliza blocos <code>try</code> e <code>except</code> para lidar com exceções. Se a renomeação for bem-sucedida, as informações no DataFrame são atualizadas. Em caso de falha, o código tenta realizar uma limpeza nos nomes, utilizando a biblioteca <code>unidecode</code> para remover caracteres especiais e acentos. Se essa tentativa de limpeza também resultar em erro, o código mantém as informações originais no DataFrame.</p>
<p>Essa estratégia abrangente permite que o código prossiga mesmo diante de possíveis problemas durante o processo de renomeação, garantindo robustez na execução do script.</p>
<pre><code class="language-py">import os
from unidecode import unidecode

def renomeia(df):
    # Itera sobre as linhas do DataFrame
    for index, linha in df.iterrows():
        print('\n')

        # Obtém o caminho antigo e o nome do arquivo antigo
        antigo_caminho = linha['Caminho']
        antigo_caminho = antigo_caminho.replace('\\', '/')
        ultima_barra = antigo_caminho.rfind('/')
        antigo_nome = antigo_caminho[ultima_barra:].replace('/','')

        # Gera o novo caminho com base no nome alterado
        novo_caminho = antigo_caminho
        ultima_barra = novo_caminho.rfind('/')
        novo_caminho = novo_caminho[:ultima_barra]
        novo_caminho = novo_caminho + '/' + linha['Arquivo_Nome_Alterado']

        # Gera um apelido para o novo caminho
        novo_apelido = novo_caminho[ultima_barra:].replace('/','')

        try:
            # Tenta renomear o arquivo e atualizar informações no DataFrame
            os.rename(antigo_caminho, novo_caminho)
            df.at[index, 'Novo_Caminho'] = str(novo_caminho).replace('/', '\\')
            df.at[index, 'Arquivo_Nome_Alterado'] = novo_apelido
        except Exception as e:
            try:
                # Se ocorrer uma exceção, tenta limpar o nome antigo usando unidecode
                antigo_nome_limpo = unidecode(antigo_nome)
                antigo_caminho_limpo = unidecode(antigo_caminho)

                # Atualiza informações no DataFrame
                df.at[index, 'Arquivo_Nome_Alterado'] = antigo_nome_limpo
                df.at[index, 'Novo_Caminho'] = str(antigo_caminho_limpo).replace('/', '\\')
                os.rename(antigo_caminho, antigo_caminho_limpo)
            except:
                # Se a limpeza também falhar, mantém as informações originais no DataFrame
                df.at[index, 'Novo_Caminho'] = linha['Caminho']
                df.at[index, 'Arquivo_Nome_Alterado'] = antigo_nome
                pass
            pass

print('Notas renomeadas com sucesso!')
</code></pre>
<div class="admonition example">
<ul>
<li><strong>df</strong>: datafrane que está sendo construído durante o código</li>
</ul>
</div>
<h2 id="50-arquivo-modulos_empresaspy">5.0 Arquivo "modulos_empresas.py"</h2>
<p>Este script foi criado com o intuito de estabelecer uma conexão com o banco de dados, realizar a extração da tabela "empresas" do data warehouse (dw) e disponibilizar esses dados para serem utilizados no script de leitura de notas fiscais (tópico 1.11 - Validação do CNPJ).</p>
<pre><code class="language-py">from sqlalchemy import create_engine
import pandas as pd
import psycopg2
import sqlalchemy


usuario = 'usuario'
senha = 'senha'
host = 'host'
porta = '123'
banco = 'dw'

engine = create_engine(f'postgresql://{usuario}:{senha}@{host}:{porta}/{banco}')


try:
    with engine.connect() as conn:

        print(&quot;Conexão com o banco de dados estabelecida com sucesso.&quot;)

        # Seu código para manipular o banco de dados
        query = &quot;select cod_empresa, empresa , cnpj from corporativo.empresas e &quot;
        global df_empresas
        df_empresas = pd.read_sql_query(query, engine)

        print('Dados carregados com sucesso')


except Exception as e:
    print(&quot;Erro detectado&quot;, e)

finally:
    # Fechar a conexão com o banco de dados (se ainda estiver aberta)
    if conn:
        conn.close()
        print('Conexão fechada.')

print(df_empresas)
print(len(df_empresas))
</code></pre>
<h2 id="60-arquivo-modulos_ler_imagempy">6.0 Arquivo "modulos_ler_imagem.py"</h2>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../API/" class="btn btn-neutral float-left" title="API"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../API/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
